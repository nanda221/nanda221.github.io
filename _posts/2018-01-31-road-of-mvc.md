---
layout: post
title:  "MVC的发展之路"
subtitle: "Road Of MVC"
date:   2018-01-31 23:59:59 +0800
background: '/img/posts/05.jpg'
---

# 前言

## MVC的意义

这里不讲MVC的诞生和基本概念(具体可参考[维基百科](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller))。从上世纪70年代被提出，它的影响力和点击率对于从事Web开发的人来说，可谓长盛不衰。从大学开始，讲Java的老师就在讲台上不断地重复这个词，到日常开发，MVC也变成了像“勾股定理”一样的真理。业界对MVC是一种设计模式or架构存在争论，这里首先引用一段关于两个概念的解释：

> 框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。

从概念来看，MVC更像是一种架构模式(architecture pattern)。一方面它不是像框架一样的具体实现，无法直接做代码级的重用；另一方面它比设计模式的范畴更大，不仅限于在设计模式级别的“技巧”式指引，也包含Web Application整个域的结构组织。类似的架构模式还有很多，包括MVC的变体MVP、MVVM等，还有CBD、django的MTV等等。

## 本文的意义

对于Web开发和前端开发，会被各种新的架构、框架所吸引。AngularJS还没全弄明白，React/Vue就已经在社区等你；服务端除了之前的SSH三件套，也有SpringMVC等不断涌现。常听周围的同学感慨新的东西怎么都学不完。本文试图从MVC入手，回顾历史，找到历史发展进程中的几个拐点和重点，形成知识的演化和层累结构。每个新生事物一定是站在之前的知识基础上做演化，并增量地解决问题。对整个链条的梳理，有助于把握每个新技术框架的本质和核心，有助于快速理解和选型。

# 正文

> 下面的每个二级标题代表一个历史阶段(Historical Stage)。

## Web开发之初

随着互联网的发展，从零几年开始，软件形态的比重开始由C/S向B/S逐渐倾斜。B/S无装机成本，对系统弱依赖，发布和迭代更敏捷，更适应互联网的产品节奏。。。这种种优势再加上现代浏览器的飞速发展和能力、性能提升，都让B/S成为更优的选择(除非重度依赖系统级能力或特定业务场景)。而Web开发一词由此诞生，逐渐成为一个技术领域。当然，这只是表象。站在架构师的眼里，两种组织形态一个东西没有变——S，即Server端，另一个东西改变了——View，即触达用户、与用户进行交互并做产品表达的视图。用户无论是软件客户端，还是浏览器页面，都是“浏览内容、操作、提交服务端、返回新的内容继续浏览”这样周而复始。从架构的角度看，视图是可替换的，而服务端是稳定的，可以和不同的视图通过不同的协议进行交互。那么这一时期的MVC就带有非常鲜明的“重Server端”的色彩。如下图：

服务端的MVC。

无论从概念还是从图示上来看，M和V的职责都非常好理解，那C到底要做哪些工作呢？我个人的总结是职责有二：用户输入的处理和输入到模型的路由。从实际的系统行为来看，控制器所做要比职责描述丰富的多：

* 一次用户操作，可能会影响多个M，即模型，即数据库的多张表。比如“新建用户这个操作”，背后会涉及用户模型和相关的其他业务模型的新增，那么控制器除了**路由**这一职责外，还负责多个模型操作的整合；
* 以B/S架构的用户交互来看，一次用户操作意味着一次http请求，那么在请求真正影响到M之前，会有很多的common operation，比如“登录态校验”、“攻击检测”、“crsf令牌校验”、“参数的组织和预处理”等等。虽然通常会由框架扩展中间件的方式来处理这些环节，但从MVC架构来看，属于用户输入的处理，也是C的职责；
* 从上图来看，M是直接影响视图的，这没错。系统通常选用像velocity这样的模板语言来编写视图，通过语法关键字标记动态内容的占位，然后把M变化后的值“镶嵌“到视图里。但从实战来看，M如何知道应该影响哪个视图模板呢？为了保持M的纯粹，不可能把这种关联关系硬编码到M中。所以，从M到V的路由，也通常由C代劳。

从上面的实战经验推演，一个现实世界的面向服务端的MVC结构如下：

从上图可以看到很多框架的影子，是的，架构永远有其抽象的一面，而框架会在其基础上衍生出很多机制，来帮助我们处理架构中没有涉及的各种问题，这一点从上图C的职责可见一斑，通过“PipeLine”、“约定大于配置”等方式，更优雅地完成“勾缝”(想象一下两块瓷砖之间的缝隙填充)。

小结一下这个阶段的特点：B/S成为主流；重服务端且使其承载所有复杂度；客户端职责纯粹：展现和提交。

## Ajax的革命

什么？Ajax和革命有什么关系？对于当下已经把Ajax作为Web开发常识的开发人员无法想象，在七八年前，Ajax是可以单独写一本书的(不信的同学可以看看《Head First Ajax》有多厚。。。)。那个年代的两道经典面试题分别为：面试时的“你会不会阿贾克斯”和笔试题目“请写出兼容IE6和FF的Ajax请求函数”。

Ajax的诞生和引入，对前端这个岗位具有划时代的意义，夸张一点说，它帮助界面工程师完成了向前端工程师的转型。这项技术拓宽了浏览器端可以承载的逻辑复杂度；而另一方面，大家对用户体验的认识再不仅仅是“像素对不对的齐，还原度高不高”，“页面局部刷新”、“懒加载”开始成为网站优化的时髦词汇，并引领前端人在这条体验的路上一直走到今天，即使从PC到无线，这些历史经验也毫不过时。

Ajax对重服务端的MVC架构产生了巨大的影响，因为无论从产品还是技术上，它带来的优势太明显：

1. 用户体验。一方面页面无刷新无打断并能快速响应用户操作，用户体验本身就非常好；另一方面它允许服务端不需要一股脑的把页面渲染需要的所有资源一股脑都返回，可以首先返回直接展示需要的内容，而通过用户交互行为才需要展示的内容可以在页面访问过程中随时异步获取，这一点既可以进一步加快页面首次展示，也允许浏览器端代码根据用户行为来动态获取内容。
2. 服务端的压力减小，这包括两方面：
    1. 请求次数和传输的payload减小。Ajax的原则是“按需取数据”，可以最大程度减少冗余的请求发起并最小化传输内容；
    2. 运算压力减小。虽然Ajax的名称中有一个x(xml)，但实际的使用中，服务端只会返回展示需要的数据，而非结构，整个展示DOM的拼装和更新交给浏览器端。这自然省去了服务端的模板拼装成本。在实际开发中，服务端甚至会返回展示需要的rawdata，从rawdata到展示需要的定制化数据之间的清洗工作也由浏览器端代劳。
3. 标准化并被广泛支持，无需插件，Out of Box。





## 本地容器化管理——前言

与其说引入Docker，不如说是引入了一种思想。围绕一件尽量内聚的事情，将运行环境和代码“封装”在一个环境里，以服务的形式对外透出。熟悉面向对象思想和编程原则的朋友一定觉得非常熟悉，只是原则的范围扩大到了整个运行环境，甚至是操作系统。这不仅提高了可移植性，更是一种组织服务的方式。

从现实来看，我们总是对自己的本地环境(开发机器)容易忽视，疏于对它的治理。

设想一下，在我们是如何在本地写代码、做研发甚至是学技术的：了解自己的系统(Mac或是其他)；通过brew/yum/apt-get安装系统工具包、安装技术栈运行环境，还有数据库、IDE及其他编程辅助程序、版本控制软件、工程化套件。。。直到新的需求出现，前面的程序将周而复始。慢慢地，你将拥有一台很“强大”的电脑，用起来非常趁手，编写的程序都可以完美运行，简直无所不能。但有两个问题需要思考。

### 交付——换台机器，我写的代码还能跑吗？

举个例子，在本地的Mac系统进行开发，使用了NodeJS Latest版本，完成了一个webapp。然后我把代码部署到测试环境——一个装有NodeJS LTS版本的CentOS系统。这里至少已经出现了两个明显的风险点，1.不同系统的NodeJS安装；2.LTS环境无法实用Latest的某些新特性。一句话：我们交付的只是代码，而不是一个对代码+环境的完整描述。可以通过增加运行环境说明(readme)来一定程度解决这个问题，但这并不可靠和优雅。

### 混乱——多版本、多技术栈

举个例子，使用jekyll搭建个人博客，需要Ruby运行环境(2.5)。Mac自带Ruby运行环境，但版本较低。对系统版本进行升级不可取(系统程序依赖低版本)，只能使用RVM做多版本管理。当我们需要用最新的Python版本完成一个爬虫程序时，同样的事情发生在Python(系统2.7)和Python3。多个技术栈和多版本(或是版本管理工具)，让本地这个“应用”非常臃肿和混乱，一段时间以后很难记得哪些技术组合解决哪些开发问题。

综上，借由Docker，我们需要对自己的本地环境做一次全新的梳理和升级。Docker帮我们做好了准备工作。它的基本概念可以参考[官方文档](https://docs.docker.com/reference/)，写的非常的清晰明白。这里对几个比较重要的环节做一些分享和探讨。


## 容器连接

进入容器有很多种方式，第一类是docker本身提供的工具。

### docker run -ti
```
docker run -t -i ubuntu:latest /bin/bash
```
-t是开启一个tty伪终端(pseudo-TTY)，将容器的标准输出展示到这里；-i则表示打开标准输入(STDIN)。这种做法简单直接，缺点也很明显：只能在创建时进入。而且显式地指定/bin/bash会覆盖镜像的CMD指令。

### attach
```
docker attach containerId   # containerId：已经运行的容器id
```
attach进入容器会有几个问题：

1. 只能进入以/bin/bash为启动命令的容器
2. 多个窗口使用该命令进入同一容器的时候所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他的窗口再也无法进行其他的操作
3. 会出现莫名其妙的卡死情况(实际使用中发现的)

### exec
官方提供的另一种方式进入容器，且简单灵活:
```
docker exec -it containerId /bin/bash # containerId：已经运行的容器id
```
这条指令很好理解，exec允许在已经运行的容器中自定义参数(如-it)和执行命令(/bin/bash)，对于docker自带工具来说，exec通常是最好的选择。

### ssh

ssh(Secure Shell)：远程登录会话协议，重点两个字：远程，这是docker上述自带工具所不具备的。而通过远程登录来管理应用或服务，对很多研发人员来说，更是一种习惯。

在笔者的工作环境，无论应用是否Docker化，从运维的角度讲，都不建议(甚至是禁止)直接远程登录服务器进行日志查询、甚至是重启等操作，取而代之的是各产品化的解决方案：比如B/S形态更产品化的日志查询、应用生命周期管理等等。但程序员对“掌控感”的渴求与生俱来，运行环境上下文中有什么、发生了什么、结果是什么，这些问题一定要到“现场”才最痛快直接。所以在测试环境等一切允许的场景，都是“登”上去一顿操作。

为容器“植入”ssh能力，从理念来看，业界也存在争论。Docker的理念是一个容器只运行一个服务，如果需要远程连接，每个容器运行一个额外的SSH守护进程服务，有违这一理念。此外也意味着引入了被更多攻击的可能。

本文讨论的更倾向本地Docker化服务管理，所以理念和风险可以适当弱化，而通过多个ip+port的方式定位服务、管理服务，是更熟悉且易于切换到分布式环境的方式。

ssh分为口令登录和免密登录(秘钥登录)，[基本概念](http://blog.csdn.net/yimingsilence/article/details/52161412)参考这里。
而秘钥登录，又涉及到公钥和私钥，且公钥私钥在普通加密和认证这两种场景的使用方式是有区别的，强烈建议阅读[这里](http://blog.51cto.com/bingdian/313319)

下文中采用的是口令登录，免密登录笔者也进行了尝试，但遇到了**Permission denied**的问题，一直无法解决(Linux权限苦手)。
ssh可以作为核心功能集成到基础镜像，在本人的[docker-libs](https://github.com/nanda221/docker-libs/blob/master/base/Dockerfile)中已经有一份样例，里面保留了很多采坑和测试的注释，可以辅助理解在镜像构建时的一些考量。下面是几行核心指令：
```
From ...
...
RUN apt-get update
# 安装sshd
RUN apt-get install -y openssh-server
# 创建运行目录
RUN mkdir /var/run/sshd
# 修改root密码
RUN echo 'root:pswd1234' | chpasswd
# 允许root登录
RUN sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config
# 官方解释：SSH login fix. Otherwise user is kicked off after login
RUN sed 's@session\s*required\s*pam_loginuid.so@session optional pam_loginuid.so@g' -i /etc/pam.d/sshd
# 创建启动脚本
RUN echo '#!/bin/bash\n/usr/sbin/sshd -D' >> /root/bootstrap.sh && chmod 755 /root/bootstrap.sh
# 添加启动进入点
ENTRYPOINT ["/root/bootstrap.sh"]
# 暴露端口，ssh约定监听端口22
EXPOSE 22
...
```
使用Dockerfile构建镜像，假设tag为sshd:0.1，然后就可以运行：
```
# 方式一：随机端口映射
docker run -d -P sshd:0.1
# 方式二：指定端口映射
docker run -d -p 10122:22 sshd:0.1
```
方式一执行后可以通过**docker port containerId查看映射的随机端口号**。
然后就可以通过**ssh root@0.0.0.0 -p portnumber**进入容器，注意，上面指定的密码为**pswd1234**

## 编程语言运行环境

根据服务的需要，要准备编程语言需要的运行环境。本人的[docker-libs](https://github.com/nanda221/docker-libs)中已经准备了一些较新且常用的语言环境镜像作为参考。

## 生命周期管理

待施工：重点阐述如何通过更产品化、界面化的方式来管理容器的启停生命周期。



















