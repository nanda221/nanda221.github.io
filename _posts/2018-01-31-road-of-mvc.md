---
layout: post
title:  "MVC的发展之路"
subtitle: "Road Of MVC"
date:   2018-01-31 23:59:59 +0800
background: '/img/posts/05.jpg'
---

<style>
.markdown-body img {
    margin: 0 auto; display: block; padding: 4px;
}
</style>

# 前言

### MVC的意义

这里不讲MVC的诞生和基本概念(具体可参考[维基百科](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller))。从上世纪70年代被提出，它的影响力和点击率对于从事Web开发的人来说，可谓长盛不衰。从大学开始，讲Java的老师就在讲台上不断地重复这个词，到日常开发，MVC也变成了像“勾股定理”一样的真理。业界对MVC是一种设计模式or架构存在争论，这里首先引用一段关于两个概念的解释：

> 框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。

从概念来看，MVC更像是一种架构模式(architecture pattern)。一方面它不是像框架一样的具体实现，无法直接做代码级的重用；另一方面它比设计模式的范畴更大，不仅限于在设计模式级别的“技巧”式指引，也包含Web Application整个域的结构组织。类似的架构模式还有很多，包括MVC的变体MVP、MVVM等，还有CBD、django的MTV等等。

### 本文的意义

对于Web开发和前端开发，会被各种新的架构、框架所吸引。AngularJS还没全弄明白，React/Vue就已经在社区等你；服务端除了之前的SSH三件套，也有SpringMVC等不断涌现。常听周围的同学感慨新的东西怎么都学不完。本文试图从MVC入手，回顾历史，找到历史发展进程中的几个拐点和重点，形成知识的演化和层累结构。每个新生事物一定是站在之前的知识基础上做演化，并增量地解决问题。对整个链条的梳理，有助于把握每个新技术框架的本质和核心，有助于快速理解和选型。

<img style="width: 60%;" src="https://img.alicdn.com/tfs/TB1mseWXTtYBeNjy1XdXXXXyVXa-1632-1224.jpg" />

# 正文

> 下面的每个小标题代表一个历史阶段(Historical Stage)。

### Web开发之初

随着互联网的发展，从零几年开始，软件形态的比重开始由C/S向B/S逐渐倾斜。B/S无装机成本，对系统弱依赖，发布和迭代更敏捷，更适应互联网的产品节奏。。。这种种优势再加上现代浏览器的飞速发展和能力、性能提升，都让B/S成为更优的选择(除非重度依赖系统级能力或特定业务场景)。而Web开发一词由此诞生，逐渐成为一个技术领域。当然，这只是表象。站在架构师的眼里，两种组织形态一个东西没有变——S，即Server端，另一个东西改变了——View，即触达用户、与用户进行交互并做产品表达的视图。用户无论是软件客户端，还是浏览器页面，都是“浏览内容、操作、提交服务端、返回新的内容继续浏览”这样周而复始。从架构的角度看，视图是可替换的，而服务端是稳定的，可以和不同的视图通过不同的协议进行交互。那么这一时期的MVC就带有非常鲜明的“重Server端”的色彩。如下图：

<img style="width: 60%;transform:rotate(-90deg); margin-top: -50px; margin-bottom: -50px;" src="https://img.alicdn.com/tfs/TB1F0RfXQCWBuNjy0FaXXXUlXXa-1224-1632.jpg" />

M和V的职责都非常纯粹，那C到底要做哪些工作呢？有一个打趣的定义是“所有不可复用的代码都应该存放到C”，这些代码包括：

* 在初始化时，构造相应的V和M。
* 监听V的事件，并将事件转发到M。
* 获取M的变化，将M的数据传递到V(注意，这点是MVC原始定义中没有的职责)。

一个B/S的场景如下：

1. 用户操作V，产生一次http提交；C接收提交命令和参数，做通用与处理流程(这里指通用处理动作，比如“登录态校验”、“攻击检测”、“crsf令牌校验”、“参数组织和预处理”等等)。
2. 根据命令和参数，调用相应的M。一次请求可能会涉及多个M，C也需要负责M的调用顺序和返回数据的整合。
3. MVC的架构图来看，M是直接影响视图的。但从实战来看，M如何知道应该影响哪个视图模板呢？为了保持M的纯粹，不可能把这种关联关系硬编码到M中。所以，从M到V的路由和展示数据的专递也由C代劳。

由此得出，一个现实世界的面向服务端的MVC结构如下：

<img style="width: 80%;" src="https://img.alicdn.com/tfs/TB16Z0lXKSSBuNjy0FlXXbBpVXa-1632-1224.jpg" />

从上图可以看到很多框架的影子，如Struts。是的，架构永远有其抽象的一面，而框架会在其基础上衍生出很多机制，来帮助我们处理架构中没有涉及的各种问题，这一点从上图C的职责可见一斑，通过PipeLine、Path Auto Mapping(约定大于配置)等方式，更优雅地完成“勾缝”(想象一下两块瓷砖之间的缝隙填充)。

小结一下这个阶段的特点：B/S成为主流；重服务端且使其承载所有复杂度；客户端职责纯粹：展现和提交。

### Ajax的革命——RIA

什么？Ajax和革命有什么关系？对于当下已经把Ajax作为Web开发常识的开发人员无法想象，在七八年前，Ajax是可以单独写一本书的(不信的同学可以看看《Head First Ajax》有多厚。。。)。那个年代的两道经典面试题分别为：面试时的“你会不会阿贾克斯”和笔试题目“请写出兼容IE6和FF的Ajax请求函数”。

**Ajax的诞生和引入，对前端这个岗位具有划时代的意义，夸张一点说，它帮助界面工程师完成了向前端工程师的转型。**这项技术拓宽了浏览器端可以承载的逻辑复杂度；而另一方面，大家对用户体验的认识再不仅仅是“像素对不对的齐，还原度高不高”，“页面局部刷新”、“懒加载”开始成为网站优化的时髦词汇，并引领前端人在这条体验的路上一直走到今天，即使从PC到无线，这些历史经验也毫不过时。

Ajax对重服务端的MVC架构产生了巨大的影响，因为无论从产品还是技术上，它带来的优势太明显：

* 用户体验。一方面页面无刷新无打断并能快速响应用户操作，用户体验本身就非常好；另一方面它允许服务端不需要一股脑的把页面渲染需要的所有资源一股脑都返回，可以首先返回直接展示需要的内容，而通过用户交互行为才需要展示的内容可以在页面访问过程中随时异步获取，这一点既可以进一步加快页面首次展示，也允许浏览器端代码根据用户行为来动态获取内容。
* 服务端的压力减小，这包括两方面：

    * 请求次数和传输的payload减小。Ajax的原则是“按需取数据”，可以最大程度减少冗余的请求发起并最小化传输内容；
    * 运算压力减小。虽然Ajax的名称中有一个x(xml)，但实际的使用中，服务端只会返回展示需要的数据，而非结构，整个展示DOM的拼装和更新交给浏览器端。这自然省去了服务端的模板拼装成本。在实际开发中，服务端甚至会返回展示需要的rawdata，从rawdata到展示需要的定制化数据之间的清洗工作也由浏览器端代劳。
* 标准化并被广泛支持，无需插件，Out of Box。

下面再引出一个时代的眼泪：[RIA](https://zh.wikipedia.org/zh-hans/RIA)(Rich Internet Applications)。下图是RIA下的胖客户端MVC架构：

<img style="width: 80%;" src="https://img.alicdn.com/tfs/TB1ntFoXQyWBuNjy0FpXXassXXa-1632-1224.jpg" />

图中可以看到，服务端输出页面到浏览器端，后续的用户操作由Ajax请求代替了页面提交。MVC在服务端和客户端的理解出现了分化。

* 在服务端视角，MVC相较于之前并没有明显改动，只是在Ajax场景输出物变了，是通过输出数据而不是结构来影响View(接口回归到数据，具有了复用性，可以提供给不同的视图出口如多端来使用)。在这种场景下，整个浏览器端在服务端眼里被抽象成了V，内部如何使用接口服务端并不关心。参考图中的M1/V1/C1。
* 在客户端视角，Ajax的目的就是为了获取Model数据，View的拼装和重绘由客户端来完成。所以，Ajax请求被整体抽象成了M，而客户端的JS逻辑——响应用户交互行为、发起响应Ajax，根据model渲染View，这正符合前文对C职责的描述，所以在客户端也出现了MVC小闭环。参考图中的M2/V2/C2。另外，由于浏览器端需要根据数据来渲染页面内容，这一时期涌现了大批动态模板语言，EJS、xTemplate、Nunjucks...他们通常同时支持浏览器和服务端(Node)渲染。

这种“混合型”MVC在历史进程中存在了很久，甚至仍是后台系统的主流设计。

这个阶段的最后，不得不提一个模式——MVP。做过Android开发的同学对MVP模式一定不陌生，MVP主要在MVC的基础上解决两个问题：

* View不直接使用Model，而是通过Presenter；
* View和Presenter间通过接口协议进行沟通。

MVP架构图：

<img style="width: 60%;transform:rotate(-90deg); margin-top: -50px; margin-bottom: -50px;" src="https://img.alicdn.com/tfs/TB1tZtpXGmWBuNjy1XaXXXCbXXa-1224-1632.jpg" />

这张图是否似曾相识？是不是和前文RIA的架构很像？的确，RIA时期的B/S软件开发已经暗合了MVP模式：Android的类库社区特别创造了Presenter这个具体类，并用Java接口的方式提供到View；B/S场景的服务端同样构建了这样的controller层，并以Ajax接口向View输出数据。

小结一下这个阶段的特点：Ajax引领前端变革，RIA下的性能和体验提升，MVP模式。

### RIA的演进——SPA

SPA(Single Page Application)基于一个很简单的假设：既然Ajax可以异步局部获取内容(数据)，那如果把一整张页面作为“局部”，是否可以实现一定场景范围内的页面动态跳转。

相较于局部内容更新，SPA需要额外处理一个问题：页面资源定位。根据URI的规则，每个页面是可以被唯一标识和到达的，所以我们需要给每一个动态页面一个可以唯一标识的URI。目前主流的方式有两种：依赖服务端重定向Browser Router和Hash Router(这里借用了react-router对这两种方式的命名)。

SPA自出现起就备受前端界推崇(虽然它有SEO等问题)。这已经不仅是体验的进一步提升，更涉及到工程方面的问题。

在一个分工细化的团队，前端和后端分别有独立的工程，也有分别的人员负责。在上一个阶段，前端工程包含了样式和一些模板片段(JS形式表示)。后端工程中也包含了所有的展示页面。从维护和工程两个角度来看，都不够纯粹和效率：
    1. 维护的角度看，一次页面的样式改动，维护的人首先要判断到底是改服务器端页面还是前端模板，进而决定改动哪个工程。
    2. 前后端需要联合发布：前端仓库发布静态资源的新版本；服务端修改静态资源版本和其他要修改的页面内容，然后发布。

SPA可以很大程度解耦这种依赖：所有的页面模板都“移”到了前端工程，服务端只留下了一个html文件(我们通常称之为entry：入口文件)。每次前端发布，服务端只需要维护一个动态的版本号。

SPA加持下的MVC架构如下：

![MVC架构图]()

清爽多了不是？这个架构还有另一个雅称：前后端分离架构。

小结一下这个阶段的特点：SPA下的前后端分离架构。


> 按理说，SPA已经在相当大的程度上解耦了前后端开发人员：一个专注V，一个专注M，Ajax提供通信方案，很完美了不是？但随着业务复杂度的提升，C的问题日益凸显，我们先来看服务端的C。

### 向后——Node带来的BFF

一句在前端界的经典抱怨：“开发给的接口不满足我的需求”。后端开发当然不服气：“我已经帮你做了很多数据处理和加工，是UI的变化太频繁，我的修改怎么可能跟得上。”

互怼没有对错，大家出发点不同。面向UI的数据接口体需求变化更频繁，并常常需要附加非持久化信息。举个例子，开发一个批量获取用户身份证列表的接口，并隐去后四位后返回(举这个例子，属于只能由服务端处理后返回，而不能由浏览器端代劳的场景)。获取身份证列表通过M获取,那“隐去后四位”这一步呢，也放在M中处理吗？稍微懂些设计原则的开发人员都不会这么做，因为隐去后四位并不是持久化信息(不存DB)，属于UI展示需要的附加信息，不能“污染”M。那么这个工作就落到了C，而对应的处理代码也称为“胶水代码”。如果某天需求改变：“隐去后六位”，只需要改动C，以此来保证M的稳定。流程如下：

![MVC架构图]()

但这还是太麻烦了！！！每次UI引起的接口变化，意味着前后端双方都要理解View的需求，并且整个后端服务要随之进行发布，这对于服务端开发的理解和运维成本都是极高的。换句话说，前文提到的“前后端分离架构”，分离的只是代码层面的模板，而不是服务端对UI的彻底分离。

**NodeJS的出现，正如向前文提到的Ajax一样，再次产生了划时代的意义(手动滑稽)，毫不夸张地说，它帮助前端工程师完成了向全栈工程师的转型。**

* 为什么是NodeJS？“轻量、高性能、异步非阻塞、Restful API...”，每个前端都能随口报出一大堆理由，但核心只有一点：语言和环境门槛。语法都是JS，运行环境都是V8，只要多掌握几十个API，即可完成“转型”。NodeJS就这样不断发展向前，**有人用，就会变得更好**，浅显的道理。
* 从第一点引申，Node做Web层有一个非常大的优势：代码复用。比如表单校验等前后端都要做的逻辑，可以以代码片段甚至UMD模块的方式做两端复用。发展到今天，NPM上托管的早已不仅是Node模块，而是所有的javascript模块生态。
* 服务端的胶水代码是客观存在的，不可能彻底消除，但能交给更懂需求的人来维护。NodeJS把前端的能力边界扩大，一些大公司的前端团队开始使用Express(or Koa)+扩展中间件的方式搭建自己的RestFul API层，做面向UI的数据加工。M向后移转化为更纯粹的核心服务层，为RestFul层提供更raw的数据。
* 上面的RestFul API层还有一个更直白的名字——BFF(BackEnd for FrontEnd)。

![MVC架构图]()

上图最显著的变化是分布式。BFF和核心服务分别拥有独立的集群，通过远程协议做连接。从整体来看，NodeJS的出现带来了额外的技术成本和更多的分层，增加了系统复杂度。但从代码和运维上换来了更大的自由度和灵活性。从关注点来看，开发真正回到到业务，前端涵盖整个UI。

为什么这种架构会先从大公司出现，和业务体量、复杂度以及人员分工都有关系。对于业务和人员更内聚的场景，传统的[Monolith Architecture](http://microservices.io/patterns/monolithic.html)也许是更好的选择。

小结一下这个阶段的特点：Web分层精细化，BFF分布式架构。

### 向前——MVVM

回到浏览器端，Controller的问题同样令人沮丧，甚至比服务端更严重。更靠近UI，导致Controller成了UI变化的一级缓冲区，胶水代码肆意堆叠。常见的功能点如下：

* 编写事件监听器获取交互行为。
* 从UI直接获取数据，做加工后传递到服务端接口。
* 获取接口返回值，通过DOM操作直接修改UI。

通过描述，基本可以看出MVVM想解决哪三个问题：

1. 数据由UI来维持(UI是数据的来源和去向)，会导致当前状态无法描述，进而问题难以跟踪；而UI作为检验的结果，也让单元测试也无从编写(测试团队进而转向UI自动化测试方向...)。
2. 过多的事件绑定。
3. 过多的DOM操作。

![MVC架构图]()

再看看MVVM的架构图：

![MVC架构图]()

先不管能不能做到，光看这架构图简直清爽到爆！而AngularJS(以下简称Ag)横空出世，毫不夸张地说，更多人是先听说的Ag，后了解的MVVM。看看它是怎么解决上面的三个问题的：

* 拥有了ViewModel的概念——Scope。作为展示数据的载体，由UI事件或服务端模型引起的变化都将反映到Scope。
* 提供了模板语法糖(ngVerb)，释放冗长的事件绑定代码。
* 通过SUB/PUB机制监听Scope变化，触发相应事件引起UI改变。Ag内置指令已经可以满足大部分UI改变的场景，当然也支持自定义指令和渲染方法。

Ag除了解决上述问题，还带来了指令(directive)和模块化管理中的依赖注入(DI)等高级特性，这对于当时的前端业界都是划时代的产物。虽然在性能、体量等方面被人诟病(后来者Vue在这几方面做了优化),但几点宝贵的设计思想可谓既往开来，影响深远:

* UI数据化：确定的数据(ViewModel)导致确定的UI，数据的变化导致UI的状态转移；问题跟踪和UI测试变得更容易。
* 声明式编程：自定义组件、属性都属于此类，从Code Block到Code Behind。

小结一下这个阶段的特点：MVVM成前端架构趋势，后继框架和模式都是在V和VM上的深耕。

# 结语

MVC的发展之路，描述到此，下篇会分享下对**React生态**的一些理解。新的技术总是层出不同，抓住一条主线，围绕它来理解新生事物，会有助于抓住其内核快速掌握，并深刻理解可以解决的问题和场景。在React的分享中，我们的主线同样可以是MVC。












