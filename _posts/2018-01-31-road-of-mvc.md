---
layout: post
title:  "MVC的发展之路"
subtitle: "Road Of MVC"
date:   2018-01-31 23:59:59 +0800
background: '/img/posts/05.jpg'
---

# 前言

## MVC的意义

这里不讲MVC的诞生和基本概念(具体可参考[维基百科](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller))。从上世纪70年代被提出，它的影响力和点击率对于从事Web开发的人来说，可谓长盛不衰。从大学开始，讲Java的老师就在讲台上不断地重复这个词，到日常开发，MVC也变成了像“勾股定理”一样的真理。业界对MVC是一种设计模式or架构存在争论，这里首先引用一段关于两个概念的解释：

> 框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。框架通常是代码重用，而设计模式是设计重用，架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。

从概念来看，MVC更像是一种架构模式(architecture pattern)。一方面它不是像框架一样的具体实现，无法直接做代码级的重用；另一方面它比设计模式的范畴更大，不仅限于在设计模式级别的“技巧”式指引，也包含Web Application整个域的结构组织。类似的架构模式还有很多，包括MVC的变体MVP、MVVM等，还有CBD、django的MTV等等。

## 本文的意义

对于Web开发和前端开发，会被各种新的架构、框架所吸引。AngularJS还没全弄明白，React/Vue就已经在社区等你；服务端除了之前的SSH三件套，也有SpringMVC等不断涌现。常听周围的同学感慨新的东西怎么都学不完。本文试图从MVC入手，回顾历史，找到历史发展进程中的几个拐点和重点，形成知识的演化和层累结构。每个新生事物一定是站在之前的知识基础上做演化，并增量地解决问题。对整个链条的梳理，有助于把握每个新技术框架的本质和核心，有助于快速理解和选型。

# 正文

> 下面的每个二级标题代表一个历史阶段(Historical Stage)。

## Web开发之初

随着互联网的发展，从零几年开始，软件形态的比重开始由C/S向B/S逐渐倾斜。B/S无装机成本，对系统弱依赖，发布和迭代更敏捷，更适应互联网的产品节奏。。。这种种优势再加上现代浏览器的飞速发展和能力、性能提升，都让B/S成为更优的选择(除非重度依赖系统级能力或特定业务场景)。而Web开发一词由此诞生，逐渐成为一个技术领域。当然，这只是表象。站在架构师的眼里，两种组织形态一个东西没有变——S，即Server端，另一个东西改变了——View，即触达用户、与用户进行交互并做产品表达的视图。用户无论是软件客户端，还是浏览器页面，都是“浏览内容、操作、提交服务端、返回新的内容继续浏览”这样周而复始。从架构的角度看，视图是可替换的，而服务端是稳定的，可以和不同的视图通过不同的协议进行交互。那么这一时期的MVC就带有非常鲜明的“重Server端”的色彩。如下图：

![MVC架构图]()

无论从概念还是从图示上来看，M和V的职责都非常好理解，那C到底要做哪些工作呢？我个人的总结是职责有二：用户输入的处理和输入到模型的路由。从实际的系统行为来看，控制器所做要比职责描述丰富的多：

* 一次用户操作，可能会影响多个M，即模型，即数据库的多张表。比如“新建用户这个操作”，背后会涉及用户模型和相关的其他业务模型的新增，那么控制器除了**路由**这一职责外，还负责多个模型操作的整合；
* 以B/S架构的用户交互来看，一次用户操作意味着一次http请求，那么在请求真正影响到M之前，会有很多的common operation，比如“登录态校验”、“攻击检测”、“crsf令牌校验”、“参数的组织和预处理”等等。虽然通常会由框架扩展中间件的方式来处理这些环节，但从MVC架构来看，属于用户输入的处理，也是C的职责；
* 从上图来看，M是直接影响视图的，这没错。系统通常选用像velocity这样的模板语言来编写视图，通过语法关键字标记动态内容的占位，然后把M变化后的值“镶嵌“到视图里。但从实战来看，M如何知道应该影响哪个视图模板呢？为了保持M的纯粹，不可能把这种关联关系硬编码到M中。所以，从M到V的路由，也通常由C代劳。

从上面的实战经验推演，一个现实世界的面向服务端的MVC结构如下：

从上图可以看到很多框架的影子，是的，架构永远有其抽象的一面，而框架会在其基础上衍生出很多机制，来帮助我们处理架构中没有涉及的各种问题，这一点从上图C的职责可见一斑，通过“PipeLine”、“约定大于配置”等方式，更优雅地完成“勾缝”(想象一下两块瓷砖之间的缝隙填充)。

小结一下这个阶段的特点：B/S成为主流；重服务端且使其承载所有复杂度；客户端职责纯粹：展现和提交。

## Ajax的革命

什么？Ajax和革命有什么关系？对于当下已经把Ajax作为Web开发常识的开发人员无法想象，在七八年前，Ajax是可以单独写一本书的(不信的同学可以看看《Head First Ajax》有多厚。。。)。那个年代的两道经典面试题分别为：面试时的“你会不会阿贾克斯”和笔试题目“请写出兼容IE6和FF的Ajax请求函数”。

Ajax的诞生和引入，对前端这个岗位具有划时代的意义，夸张一点说，它帮助界面工程师完成了向前端工程师的转型。这项技术拓宽了浏览器端可以承载的逻辑复杂度；而另一方面，大家对用户体验的认识再不仅仅是“像素对不对的齐，还原度高不高”，“页面局部刷新”、“懒加载”开始成为网站优化的时髦词汇，并引领前端人在这条体验的路上一直走到今天，即使从PC到无线，这些历史经验也毫不过时。

Ajax对重服务端的MVC架构产生了巨大的影响，因为无论从产品还是技术上，它带来的优势太明显：

1. 用户体验。一方面页面无刷新无打断并能快速响应用户操作，用户体验本身就非常好；另一方面它允许服务端不需要一股脑的把页面渲染需要的所有资源一股脑都返回，可以首先返回直接展示需要的内容，而通过用户交互行为才需要展示的内容可以在页面访问过程中随时异步获取，这一点既可以进一步加快页面首次展示，也允许浏览器端代码根据用户行为来动态获取内容。
2. 服务端的压力减小，这包括两方面：
    1. 请求次数和传输的payload减小。Ajax的原则是“按需取数据”，可以最大程度减少冗余的请求发起并最小化传输内容；
    2. 运算压力减小。虽然Ajax的名称中有一个x(xml)，但实际的使用中，服务端只会返回展示需要的数据，而非结构，整个展示DOM的拼装和更新交给浏览器端。这自然省去了服务端的模板拼装成本。在实际开发中，服务端甚至会返回展示需要的rawdata，从rawdata到展示需要的定制化数据之间的清洗工作也由浏览器端代劳。
3. 标准化并被广泛支持，无需插件，Out of Box。

下面再引出一个时代的眼泪：[RIA](https://zh.wikipedia.org/zh-hans/RIA)(Rich Internet Applications)。下图是RIA下的胖客户端MVC架构：

![MVC架构图]()

图中可以看到，服务端输出页面到浏览器端，后续的用户操作由Ajax请求代替了页面提交。MVC在服务端和客户端的理解出现了分化。

站在服务端的视角，MVC相较于之前并没有明显改动，只是在Ajax场景输出物变了，是通过输出数据而不是结构来影响View。
而在客户端视角，Ajax的目的就是为了获取Model数据，View的拼装和重绘由客户端来完成。所以，Ajax请求被整体抽象成了M，而客户端的JS逻辑——响应用户交互行为、发起响应Ajax，根据model渲染View，这正符合前文对C职责的描述。

因为浏览器端需要根据数据来渲染页面内容，这一时期涌现了大批模板语言，EJS、xTemplate、Nunjucks...他们通常同时支持浏览器和服务端(Node)渲染。

这种“混合型”MVC在历史进程中存在了很久，甚至仍是后台系统的主流设计。


小结一下这个阶段的特点：Ajax引领前端变革，RIA下的性能和体验提升。

## RIA的演进——SPA

SPA(Single Page Application)基于一个很简单的假设：既然Ajax可以异步局部获取内容(数据)，那如果把一整张页面作为“局部”，是否可以实现一定场景范围内的页面动态跳转。

相较于局部内容更新，SPA需要额外处理一个问题：页面资源定位。根据URI的规则，每个页面是可以被唯一标识和到达的，所以我们需要给每一个动态页面一个可以唯一标识的URI。目前主流的方式有两种：依赖服务端重定向Browser Router和Hash Router(这里借用了react-router对这两种方式的命名)。

管不了什么SEO(爬虫会越来越聪明的不是吗：）)，SPA自出现起就备受前端推崇。这已经不仅是体验的进一步提升，更涉及到工程方面的问题。

在一个分工细化的团队，前端和后端分别有独立的工程，也有分别的人员负责。在上一个阶段，前端工程包含了样式和一些模板片段(JS形式表示)。后端工程中也包含了所有的展示页面。从维护和工程两个角度来看，都不够纯粹和效率：
    1. 维护的角度看，一次页面的样式改动，维护的人首先要判断到底是改服务器端页面还是前端模板，进而决定改动哪个工程。
    2. 前后端需要联合发布：前端仓库发布静态资源的新版本；服务端修改静态资源版本和其他要修改的页面内容，然后发布。

SPA可以很大程度解耦这种依赖：所有的页面模板都“移”到了前端工程，服务端只留下了一个html文件(我们通常称之为entry：入口文件)。每次前端发布，服务端只需要维护一个动态的版本号。

SPA加持下的MVC架构如下：

![MVC架构图]()

清爽多了不是？这个架构还有另一个雅称：前后端分离架构。

小结一下这个阶段的特点：SPA下的前后端分离架构。

## 下一步：解决胶水代码——向前进，向后进

按理说，SPA已经在相当大的程度上解耦了前后端开发人员：一个专注V，一个专注M，Ajax提供通信方案，很完美了不是？但随着技术的发展和项目复杂度的提升，C的问题日益凸显，我们先来看服务端的C。

### 向后进——Node带来的BFF

一句在前端界的经典抱怨：“开发给的接口不满足我的需求”。后端开发当然也不服气：“我已经帮你做了很多数据处理和加工，是UI的变化太频繁，我的修改怎么可能跟得上。”

这种互怼没有对错，大家出发点不同。面向UI的数据接口和传统的后端接口开发不同，体现在：变化更频繁、需要附加非持久化信息等等。举个例子，开发一个批量获取用户身份证列表的接口，并隐去后四位后返回。获取身份证列表很简单明确，通过M来获取；“隐去后四位”这一步呢，也放在M中处理吗？一个稍微懂些设计原则的开发都不会这么做，因为隐去后四位并不是持久化信息(不存DB)，属于UI展示需要的附加信息，不能“污染”M。那么这个工作就落到了C，而对应的处理代码也称为“胶水代码”。如果某天需求改变：“隐去后六位”，只需要改动C，以此来保证M的稳定。流程如下：

![MVC架构图]()

但这还是太麻烦了！！！每次UI引起的接口变化，都意味着前后端双方都要理解View的需要，并且整个后端服务要随之进行发布，这对于开发和运维成本都是极高的。
